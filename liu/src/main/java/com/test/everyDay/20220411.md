Q:1.master如何判断一个slave是否是第一次同步？同步
A:slave原本也是一个master,有自己的replication id和offset,与master连接时，将自己的relication id 和offset发送给master,master收到relication id后，
  发现与自己的relication id不一致，master就可以判断该slave是第一次连接，于是开始全量同步，master会将自己的replid和offset都发送给这个slave，
  slave保存这些信息，master和slave的replid就保持一致了
  全量同步过程:(1)slave节点请求增量同步(2)master检查replid不一致，拒绝增量同步，开始全量同步(3)master将完整的内存数据生成RDB文件，发送给slave
              (4)slave清空本地数据，加载RDB文件(5)master将RDB期间接收到的命令记录在repl_baklog，并持续将log中的命令发送给slave(6)slave执行接收到的命令，与master保持同步
  增量同步过程:(1)slave请求增量同步(2)master检查replid是否一致(3)一致 去repl_baklog中获取offset后的数据 (4)发送offset后的命令(5)执行命令
  master与slave的数据差异部分在repl_baklog文件，repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset；
  slave和master的offset之间的差异就是slave需要拷贝的数据了；
  
Q:2.全量同步和增量同步区别？
A:全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。
  增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave
 
Q:3.谈一下死锁产生的原因以及怎么破坏死锁
A:死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象
  java 死锁产生的四个必要条件
   1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用
   2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。
   3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。
   4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路
  破坏死锁
   1、破坏“不抢占”条件 当某个进程请求新的资源得不到满足时，便立即释放保持的所有资源，待以后需要时再重新申请。
   2、破坏“请求和保持”条件 所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源。或者进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。
   3.破坏“循环等待”条件 可采用顺序资源分配法来使循环等待条件不成立。 原理：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象，进而预防死锁的发生。
   
Q:4.描述cookie和session的作用、区别和应用范围，Session工作原理
A:Session用于保存每个用户的专用信息. 每个客户端用户访问时，服务器都为每个用户分配一个唯一的会话ID（Session ID) . 她的生存期是用户持续请求时间再加上一段时间(一般是20分钟左右).
  Session中的信息保存在Web服务器内容中,保存的数据量可大可小.当 Session超时或被关闭时将自动释放保存的数据信息.由于用户停止使用应用程序后它仍然在内存中保持一段时间,因此使用Session对象使保存用户数据的方法效率很低.
  对于小量的数据,使用Session对象保存还是一个不错的选择
  Cookie 用于保存客户浏览器请求服务器页面的请求信息,程序员也可以用它存放非敏感性的用户信息，信息保存的时间可以根据需要设置.如果没有设置Cookie失效日期,它们仅保存到关闭浏览器程序为止.
  如果将Cookie对象的Expires属性设置为Minvalue,则表示Cookie永远不会过期.Cookie存储的数据量很受限制,大多数浏览器支持最大容量为4K,因此不要用来保存数据集及其他大量数据.
  由于并非所有的浏览器都支持Cookie,并且数据信息是以明文文本的形式保存在客户端的计算机中,因此最好不要保存敏感的,未加密的数据,否则会影响网站的安全性
  session工作原理
  (1)当有Session启动时，服务器生成一个唯一值，称为Session ID（好像是通过取进程ID的方式取得的）。
  (2)然后，服务器开辟一块内存，对应于该Session ID。
  (3)服务器再将该Session ID写入浏览器的cookie。
  (4)服务器内有一进程，监视所有Session的活动状况，如果有Session超时或是主动关闭，服务器就释放改内存块。
  (5)当浏览器连入IIS时并请求的ASP内用到Session时，IIS就读浏览器Cookie中的Session ID。
  (6)然后，服务检查该Session ID所对应的内存是否有效。
  (7)如果有效，就读出内存中的值。
  (8)如果无效，就建立新的Session。
  
Q:5.说一下类的加载过程
A:加载-->验证-->准备-->解析-->初始化
  类加载过程：三阶段
            阶段一：加载阶段（loading），得到Class对象
            1.通过一个类的全限定名获取定义此类的二进制字节流
            2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构：Class<?>对象
            3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
            阶段二：链接阶段(linking)
            1、验证 Verify
            目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
            主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。            
            2、准备 Prepare：为类静态变量初始化
            为类变量分配内存并且设置该类变量的默认初始值，即零值。            
            3、解析 Resolve
            将常量池内的符号引用转换为直接引用的过程。
            阶段三：初始化阶段：类静态变量初始化赋值，执行静态代码块
            初始化阶段就是执行类构造器法<clinit>()的过程。此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来
            
Q：高并发限流有什么算法？分别适用于什么样的场景
A: 缓存
   缓存比较好理解，在大型高并发系统中，如果没有缓存数据库将分分钟被爆，系统也会瞬间瘫痪。使用缓存不单单能够提升系统访问速度、提高并发访问量，也是保护数据库、保护系统的有效方式。大型网站一般主要是“读”，缓存的使用很容易被想到。在大型“写”系统中，缓存也常常扮演者非常重要的角色。
   比如累积一些数据批量写入，内存里面的缓存队列（生产消费），以及HBase写数据的机制等等也都是通过缓存提升系统的吞吐量或者实现系统的保护措施。甚至消息中间件，你也可以认为是一种分布式的数据缓存。
   降级
   服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。
   根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好。
   限流
   限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。
   限流的算法
   常见的限流算法有：计数器、漏桶和令牌桶算法。
   计数器
   计数器是最简单粗暴的算法。比如某个服务最多只能每秒钟处理100个请求。我们可以设置一个1秒钟的滑动窗口，窗口中有10个格子，每个格子100毫秒，每100毫秒移动一次，每次移动都需要记录当前服务请求的次数。内存中需要保存10次的次数。
   可以用数据结构LinkedList来实现。格子每次移动的时候判断一次，当前访问次数和LinkedList中最后一个相差是否超过100，如果超过就需要限流了。
   漏桶算法
   漏桶算法即leaky bucket是一种非常常用的限流算法，可以用来实现流量整形（Traffic Shaping）和流量控制（Traffic Policing）
   漏桶算法的主要概念如下： 
   一个固定容量的漏桶，按照常量固定速率流出水滴；  
   如果桶是空的，则不需流出水滴；
   可以以任意速率流入水滴到漏桶；
   如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。   