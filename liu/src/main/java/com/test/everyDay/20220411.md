Q:1.master如何判断一个slave是否是第一次同步？同步
A:slave原本也是一个master,有自己的replication id和offset,与master连接时，将自己的relication id 和offset发送给master,master收到relication id后，
  发现与自己的relication id不一致，master就可以判断该slave是第一次连接，于是开始全量同步，master会将自己的replid和offset都发送给这个slave，
  slave保存这些信息，master和slave的replid就保持一致了
  全量同步过程:(1)slave节点请求增量同步(2)master检查replid不一致，拒绝增量同步，开始全量同步(3)master将完整的内存数据生成RDB文件，发送给slave
              (4)slave清空本地数据，加载RDB文件(5)master将RDB期间接收到的命令记录在repl_baklog，并持续将log中的命令发送给slave(6)slave执行接收到的命令，与master保持同步
  增量同步过程:(1)slave请求增量同步(2)master检查replid是否一致(3)一致 去repl_baklog中获取offset后的数据 (4)发送offset后的命令(5)执行命令
  master与slave的数据差异部分在repl_baklog文件，repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset；
  slave和master的offset之间的差异就是slave需要拷贝的数据了；
  
Q:2.全量同步和增量同步区别？
A:全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。
  增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave
 
Q:3.谈一下死锁产生的原因以及怎么破坏死锁
A:死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象
  java 死锁产生的四个必要条件
   1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用
   2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。
   3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。
   4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路
  破坏死锁
   1、破坏“不抢占”条件 当某个进程请求新的资源得不到满足时，便立即释放保持的所有资源，待以后需要时再重新申请。
   2、破坏“请求和保持”条件 所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源。或者进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。
   3.破坏“循环等待”条件 可采用顺序资源分配法来使循环等待条件不成立。 原理：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象，进而预防死锁的发生。
   
Q:4.描述cookie和session的作用、区别和应用范围，Session工作原理
A:Session用于保存每个用户的专用信息. 每个客户端用户访问时，服务器都为每个用户分配一个唯一的会话ID（Session ID) . 她的生存期是用户持续请求时间再加上一段时间(一般是20分钟左右).
  Session中的信息保存在Web服务器内容中,保存的数据量可大可小.当 Session超时或被关闭时将自动释放保存的数据信息.由于用户停止使用应用程序后它仍然在内存中保持一段时间,因此使用Session对象使保存用户数据的方法效率很低.
  对于小量的数据,使用Session对象保存还是一个不错的选择
  Cookie 用于保存客户浏览器请求服务器页面的请求信息,程序员也可以用它存放非敏感性的用户信息，信息保存的时间可以根据需要设置.如果没有设置Cookie失效日期,它们仅保存到关闭浏览器程序为止.
  如果将Cookie对象的Expires属性设置为Minvalue,则表示Cookie永远不会过期.Cookie存储的数据量很受限制,大多数浏览器支持最大容量为4K,因此不要用来保存数据集及其他大量数据.
  由于并非所有的浏览器都支持Cookie,并且数据信息是以明文文本的形式保存在客户端的计算机中,因此最好不要保存敏感的,未加密的数据,否则会影响网站的安全性
  session工作原理
  (1)当有Session启动时，服务器生成一个唯一值，称为Session ID（好像是通过取进程ID的方式取得的）。
  (2)然后，服务器开辟一块内存，对应于该Session ID。
  (3)服务器再将该Session ID写入浏览器的cookie。
  (4)服务器内有一进程，监视所有Session的活动状况，如果有Session超时或是主动关闭，服务器就释放改内存块。
  (5)当浏览器连入IIS时并请求的ASP内用到Session时，IIS就读浏览器Cookie中的Session ID。
  (6)然后，服务检查该Session ID所对应的内存是否有效。
  (7)如果有效，就读出内存中的值。
  (8)如果无效，就建立新的Session。
  
Q:5.说一下类的加载过程

Q：高并发限流有什么算法？分别适用于什么样的场景
    