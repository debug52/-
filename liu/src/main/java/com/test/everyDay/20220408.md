Q:1.介绍下Redis的多路复用 redis6.0后的改动
A:I/O 多路复用模型是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，
  当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），依次顺序的处理就绪的流，
  这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个
  连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），
  主要以上两点造就了Redis具有很高的吞吐量。select/epoll 机制。

Q：2.说一下sync和volatile的区别是什么
A：volatile是一个类型修饰符（type specifier）。它是被设计用来修饰被不同线程访问和修改的变量。确保本条指令不会因编译器的优化而省略，且要求每次直接读值
   Java语言的关键字，可用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。
   当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。
   然而，当一个线程访问object的一个加锁代码块时，另一个线程仍然可以访问该object中的非加锁代码块。
   
Q:3.在使用HashMap的时候,用String做key有什么好处
A:HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，
  不需要再次计算，所以相比于其他对象更快。

Q:4.说说反射机制
A:反射机制：Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；
           这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。
  java反射机制有三个动态特性：（1）运行时生成对象实例。（2）运行时调用方法.（3）运行时更改属性。

Q:5.mysql索引在什么情况下失效
A:(1)不满足最左匹配原则（2）使用select * （3） 索引列上有计算 （4）索引列用了函数（5）字段类型不同（6）like左边包含%（7）列对比（8）or（9）not in和not exists（10）order by的坑

Q:算法题：无序数组中寻找第K大个元素
A:(1)先把无序数组从大到小进行排序，排序后的第k个元素自然就是数组中的第k大元素。但是这种方法的时间复杂度是O(nlogn),性能有些差。
  (2)维护一个长度为k的数组A的有序数组，用于存储已知的K个较大的元素。然后遍历无序数组，每遍历到一个元素，和数组A中的最小元素进行比较，
     如果小于等于数组A中的最小元素，继续遍历;如果大于数组A中的最小元素，则插入到数组A中，并把曾经的最小元素"挤出去"。
     时间复杂度是O(nk)，但是如果K的值比较大的话，其性能可能还不如方法一
  (3)小顶堆法 二叉堆是一种特殊的完全二叉树，它包含大顶堆和小顶堆两种形式。其中小顶堆的特点是每一个父节点都小于等于自己的两个子节点。   
     维护一个容量为K的小顶堆，堆中的K个节点代表着当前最大的K个元素，而堆顶显然是这K个元素中的最小值。
     遍历原数组，每遍历一个元素，就和堆顶比较，如果当前元素小于等于堆顶，则继续遍历;如果元素大于堆顶，则把当前元素放在堆顶位置，并调整二叉堆（下沉操作）
     遍历结束后，堆顶就是数组的最大K个元素中的最小值，也就是第K大元素。
     时间复杂度 1.构建堆的时间复杂度是O(K) 2.遍历剩余数组的时间复杂度O(n-K) 3.每次调整堆的时间复杂度是O(logk) 其中2和3是嵌套关系，1和2,3是并列关系，所以总的最坏时间复杂度是O((n-k)logk + k)。
     当k远小于n的情况下，也可以近似地认为是O(nlogk)。
  (4)分治法  快速排序利用分治法，每一次把数组分成较大和较小元素两部分。
     我们在寻找第K大元素的时候，也可以利用这个思路，以某个元素A为基准，把大于A的元素都交换到数组左边，小于A的元素交换到数组右边。
     时间复杂度甚至优于小顶堆法，可以达到O(n)。  