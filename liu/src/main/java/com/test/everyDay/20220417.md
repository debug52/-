Q:1.foreach为什么比for循环快
A:普通for是依靠遍历，增强for是依靠迭代器
  foreach 只能用于遍历，不能更改循环目标，遍历速度快，执行效率高。
  for 循环可以用于任何形式的重复行为，在循环体中可以进行任何操作，遍历速度慢，执行效率低。
  一般来说 数组循环普通for快 链表循环foreach快
  
Q:2.kafka高吞吐量的原因是什么
A:一. 顺序读写，避免了随机写的硬盘磁头的寻道，只需很少的扇区旋转。
  二.Page Cache，Kafka的数据并不是实时的写入硬盘，利用OS的分页存储提高I/O效率，flush后才真正写到磁盘。
  三.零拷贝，建立了磁盘空间和内存的直接映射，数据不再需要复制到"用户态缓冲区"。
  四.分区分段+索引（稀疏索引）
  通过分区分段的设计，Kafka的message消息实际上是分布式存储在一个一个小的segment中的，每次文件操作也是直接操作的segment。为了进一步的查询优化，Kafka又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度。
  五.批量读写和数据压缩

Q:3.JVM调优常用的命令和参数是什么
A:-Xms256m -Xmx512m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=E:\java-heap\claim\heapdump${current_date}.hprof
  -XX:+HeapDumpOnOutOfMemoryError 启动内存溢出监控生成dump报告
  -XX:HeapDumpPath 指定的文件件必须存在（如果不设置此参数默认存到项目当前目录下）
  注：文件夹必须存在
  查看运行的java项目及对应进程号 jps -l
  查看项目启动指定的参数设置 jinfo -flag  参数名   进程号
  查看项目启动所有的参数设置 jinfo -flags   进程号
  常用参数设置
   Xms256m 等价与 -XX:InitialHeapSize=256m 不设置默认为物理机内存的1/64
   Xmx512m 等价与 -XX:MaxHeapSize=512m 不设置默认为物理机内存的1/4或1g（1/4或1g应该是哪个大用哪个待测）
   
Q:4.Hash冲突怎么解决
A：1.开放定址法   2.再哈希法  3.链地址法（拉链法） HashMap，HashSet其实都是采用的拉链法来解决哈希冲突的
   就是在每个位桶实现的时候，我们采用链表（jdk1.8之后采用链表+红黑树）的数据结构来去存取发生哈希冲突的输入域的关键字（也就是被哈希函数映射到同一个位桶上的关键字）
   ①插入操作：在发生哈希冲突的时候，我们输入域的关键字去映射到位桶（实际上是实现位桶的这个数据结构，链表或者红黑树）中去的时候，我们先检查带插入元素x是否出现在表中，很明显，这个查找所用的次数不会超过装载因子（n/m:n为输入域的关键字个数，m为位桶的数目），它是个常数，所以插入操作的最坏时间复杂度为O(1)的。  
   ②查询操作：和①一样，在发生哈希冲突的时候，我们去检索的时间复杂度不会超过装载因子，也就是检索数据的时间复杂度也是O(1)的  
   ③删除操作：如果在拉链法中我们想要使用链表这种数据结构来实现位桶，那么这个链表一定是双向链表，因为在删除一个元素x的时候，需要更改x的前驱元素的next指针的属性，把x从链表中删除。这个操作的时间复杂度也是O(1)的。
   优点 
   与开放定址法相比，拉链法有如下几个优点：
   ①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
   ②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；
   ③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；
   ④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。
   缺点 指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。
  
Q:5.Mysql2000K万数 redis只存20W数据 据怎么保证redis存的数据是热点数据
A:对于保留 Redis 热点数据来说，我们可以使用 Redis 的内存淘汰策略来实现，可以使用allkeys-lru淘汰策略，
  该淘汰策略是从 Redis 的数据中挑选最近最少使用的数据删除，这样频繁被访问的数据就可以保留下来了。