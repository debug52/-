Q:1.java的内存模型
Q:2.TCP长连接如何实现
A:应用层的心跳机制
  通过应用程序自身发送心跳包去检测连接是否正常，基本方法就是在服务器端设置一个Timer事件，在一定时间段内向客户端一个心跳数据包，若在一定时间内没有收到客户端的回应，那么就会认为客户端掉线；同样客户端在一定时间段内没有收到服务器的心跳包，则判断与服务器端连接断开。  
  TCP的keepalive机制
  其实跟心跳机制大同小异，无论是客户端还是服务器端，只要有一方开启Keepalive功能后，就会在特定的时间段内发送心跳包，对端在收到心跳包后进行回复，表示自己在线。默认的Keepalive超时时间为2小时，探测次数为5次，但超时时间可以手动设置成合理的时间段。

Q:3.Spring框架中哪些地方分别用到了什么设计模式
A:1.工厂设计模式：Spring使用工厂模式通过BeanFactory和ApplicationContext创建bean对象。 
  2.代理设计模式：Spring AOP功能的实现。
  3.单例设计模式：Spring中的bean默认都是单例的。
  4.模板方法模式：Spring中的jdbcTemplate、hibernateTemplate等以Template结尾的对数据库操作的类，它们就使用到了模板模式。
  5.包装器设计模式：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
  6.观察者模式：Spring事件驱动模型就是观察者模式很经典的一个应用。
  7.适配器模式：Spring AOP的增强或通知（Advice）使用到了适配器模式、Spring MVC中也是用到了适配器模式适配Controller。
  
Q:4.redis持久化方式rdb和aof的区别 怎么选择应用哪一种
A:RDB（Redis DataBase）:在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；
                       redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。
                       对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。
                       如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。
                       缺点：对数据的完整性非常敏感，那么RDB方式就不太适合。因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。
  AOF（Append Only File）:将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。
                          通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。
                          默认的AOF持久化策略是每秒钟fsync一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。
                          如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。
                          因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。
                          举个例子或许更形象，假如我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，完全可以把这100条指令合并成一条SET指令，这就是重写机制的原理。
                          在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性，这点大家可以放心。
                          AOF方式的另一个好处，我们通过一个“场景再现”来说明。某同学在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清空了，这是很悲剧的事情。不过这也不是世界末日，
                          只要redis配置了AOF持久化方式，且AOF文件还没有被重写（rewrite），我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了。
                          缺点：AOF每秒fsync一次指令硬盘，如果硬盘IO慢，会阻塞父进程；风险是会丢失1秒多的数据；在Rewrite过程中，主进程把指令存到mem-buffer中，最后写盘时会阻塞主进程。
  AOF坏文件怎么恢复：1.备份被写坏的AOF文件 2.运行redis-check-aof –fix进行修复 3.用diff -u来看下两个文件的差异，确认问题点 4.重启redis，加载修复后的AOF文件
  AOF重写原理：1.在重写即将开始之际，redis会创建（fork）一个“重写子进程”，这个子进程会首先读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。
              2.与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。
              3.当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。
              4.当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中了。                          
  同时使用的话，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。
  
Q:5.假如老年代内存充足的情况下，hashMap放了一百万条数据，会出现什么性能问题

Q：寻找数组中出现次数最多的元素