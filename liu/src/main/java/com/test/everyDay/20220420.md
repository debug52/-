Q:1.redis五种数据类型以及应用场景
A:字符串 字符串类型是Redis最基础的数据结构，字符串类型可以是JSON、XML甚至是二进制的图片等数据，但是最大值不能超过512MB。
        场景:  1.缓存 在web服务中，使用MySQL作为数据库，Redis作为缓存。由于Redis具有支撑高并发的特性，通常能起到加速读写和降低后端压力的作用。
                      web端的大多数请求都是从Redis中获取的数据，如果Redis中没有需要的数据，则会从MySQL中去获取，并将获取到的数据写入redis。
               2.计数 Redis中有一个字符串相关的命令incr key，incr命令对值做自增操作，返回结果分为以下三种 值不是整数，返回错误 值是整数，返回自增后的结果 key不存在，默认键为0，返回1
                      比如文章的阅读量，视频的播放量等等都会使用redis来计数，每播放一次，对应的播放量就会加1，同时将这些数据异步存储到数据库中达到持久化的目的。
               3.共享Session 在分布式系统中，用户的每次请求会访问到不同的服务器，这就会导致session不同步的问题，假如一个用来获取用户信息的请求落在A服务器上，
                             获取到用户信息后存入session。下一个请求落在B服务器上，想要从session中获取用户信息就不能正常获取了，因为用户信息的session在服务器A上，
                             为了解决这个问题，使用redis集中管理这些session，将session存入redis，使用的时候直接从redis中获取就可以了。
               4.限速  为了安全考虑，有些网站会对IP进行限制，限制同一IP在一定时间内访问次数不能超过n次。
  哈希 Redis中，哈希类型是指一个键值对的存储结构。
        场景    将以上信息存入redis，用表明:id作为key，用户属性作为值： hsetuser:1nameJava旅途 age 18
  列表 列表类型用来存储多个有序的字符串，一个列表最多可以存储2^32-1个元素，列表的两端都可以插入和弹出元素。
        场景:  1.消息队列  列表用来存储多个有序的字符串，既然是有序的，那么就满足消息队列的特点。使用lpush+rpop或者rpush+lpop实现消息队列。
                          除此之外，redis支持阻塞操作，在弹出元素的时候使用阻塞命令来实现阻塞队列。     
              2.栈   由于列表存储的是有序字符串，满足队列的特点，也就能满足栈先进后出的特点，使用lpush+lpop或者rpush+rpop实现栈。
              3.文章列表  因为列表的元素不但是有序的，而且还支持按照索引范围获取元素。因此我们可以使用命令lrange key 0 9分页获取文章列表
  集合  集合类型也可以保存多个字符串元素，与列表不同的是，集合中不允许有重复元素并且集合中的元素是无序的。一个集合最多可以存储2^32-1个元素。
        场景: 1.用户标签 例如一个用户对篮球、足球感兴趣，另一个用户对橄榄球、乒乓球感兴趣，这些兴趣点就是一个标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同感兴趣的标签。
                        给用户打标签的时候需要①给用户打标签，②给标签加用户，需要给这两个操作增加事务。
              2. 抽奖功能 集合有两个命令支持获取随机数，分别是： 随机获取count个元素，集合元素个数不变  srandmember key [count] 
                                                            随机弹出count个元素，元素从集合弹出，集合元素个数改变  spop key [count]
                         用户点击抽奖按钮，参数抽奖，将用户编号放入集合，然后抽奖，分别抽一等奖、二等奖，如果已经抽中一等奖的用户不能参数抽二等奖则使用spop，反之使用srandmember。
  有序集合 有序集合和集合一样，不能有重复元素。但是可以排序，它给每个元素设置一个score作为排序的依据。最多可以存储2^32-1个元素。
        场景: 1.排行榜 用户发布了n篇文章，其他人看到文章后给喜欢的文章点赞，使用score来记录点赞数，有序集合会根据score排行。
              2.延迟消息队列 下单系统，下单后需要在15分钟内进行支付，如果15分钟未支付则自动取消订单。将下单后的十五分钟后时间作为score，订单作为value存入redis，消费者轮询去消费，
                            如果消费的大于等于这笔记录的score，则将这笔记录移除队列，取消订单。 
                            
   在开发中，字符串类型是用的最多的数据类型，导致我们忽视了redis的其他四种数据类型，在具体场景下选择具体的数据类型对提升redis性能有非常大的帮助。
   redis虽然支持消息队列的实现，但是并不支持ack。所以redis实现的消息队列不能保证消息的可靠性，除非自己实现消息确认机制，不过这非常麻烦，
   所以如果是重要的消息还是推荐使用专门的消息队列去做。  
   
                                                                                                                               
Q:2.怎么引入其他服务的bean
A:@ComponentScan或者@Import注解 或者spring.factories去指定

Q:3.notify和notifyAll的区别
A:notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。
  notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法。
  比如在生产者-消费者里面的使用，每次都需要唤醒所有的消费者或是生产者，以判断程序是否可以继续往下执行。
  
Q:4.Spring bean的生命周期
A:1、实例化一个Bean
  2、按照Spring上下文对实例化的Bean进行配置，也就是IOC注入
  3、如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，传递的参数就是Spring配置文件中Bean的id值
  4、如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(BeanFactory)，传递的是Spring工厂自身
  5、如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文
  6、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；
  7、如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。
  8、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法
  9、当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法；
  10、最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。
  
Q:5.高并发中concurrentHashMap和HashMap的区别
A:1、HashMap
      数据结构：数组 + 链表 + 红黑树安全性：非线程安全，因为底层代码操作数组时未加锁。应用场景：高并发情况下，put、remove 成员变量时可能发生线程安全问题，
      需加锁；操作非成员标量时不会生线程安全问题，可以不用加锁  
      扩容：元素插入后判断数组长度是否超阀，默认阀值0.75，若超阀则进行扩容，扩容大小为原数组的2的幂次方，若内存上午连续的可用空间，则申请新的可用连续空间，
      将旧数组复制到新的地址，再将旧数组置位null，等待GC回收。缩容：无动态缩容机制，需手动缩容。
  2、concurrentHashMap
     数据结构：分段数组 + 链表 + 红黑树安全性：线程安全，因为底层代码在操作每一个segment时都会对segment加锁，保证线程安全。
     应用场景：高并发情况下，线程安全，操作成员变量或局部变量都不需要单独加锁处理。
     性能：读取数据时不加锁，高效，且因为map中的value值是添加volatile关键字修饰的，可保证读取到最新值，降低CPU负载。写入数据时，
     会先通过hashcode算法算出要写入的segment（桶的位置），然后锁定当前segment，而不是锁定整个数组，所以读写效率比hashTable要高很多。
 