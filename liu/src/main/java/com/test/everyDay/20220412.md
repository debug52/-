Q：1.Mysql索引过多会产生什么问题
A:MySQL中数据是以文件的形式存放在磁盘上的.
  data/mysql/users.frm 表结构
  data/mysql/users.MYD 数据
  data/mysql/users.MYI 索引
  一张MyISAM表主要对应着三个文件,frm存表结构,MYD存表数据,MYI存表索引.
  如果一张表的数据量太大的话,那么MYD和MYI就会变的很大,查找数据就会变慢.
  
  InnoDB(innodb_file_per_table=1):
  data/wordpress/wp_users.frm 表结构
  data/wordpress/wp_users.ibd 数据和索引
  建立索引的字段越多,那数据量大的时候,文件就会越大,这是最显著的问题.
  经常出现在where子句中作为查询条件的字段就应该建立索引. 
  一个索引会在 update 或 insert 时增加一次 I/O，对于操作系统底层来说是非常损耗性能的。
 
 总结:索引过多一定情况下会导致索引文件过大(指数增长)，系统在寻址时查询时间增长。
 
Q：2.订单超时未支付自动关闭有几种实现方案
A:①数据库轮询  思路：该方案通常是在小型项目中使用，即通过一个线程定时的去扫描数据库，通过订单时间来判断是否有超时的订单，然后进行 update 或 delete 等操作。
  优点：简单易行，支持集群操作 
  缺点：对服务器内存消耗大；存在延迟，比如你每隔 3 分钟扫描一次，那最坏的延迟时间就是 3 分钟；假设你的订单有几千万条，每隔几分钟这样扫描一次，数据库损耗极大。
  ②JDK 的延迟队列 思路：该方案是利用 JDK 自带的 DelayQueue 来实现，这是一个无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素，放入 DelayQueue 中的对象，是必须实现 Delayed 接口的。
                       其中 Poll()：获取并移除队列的超时元素，没有则返回空。take()：获取并移除队列的超时元素，如果没有则 wait 当前线程，直到有元素满足超时条件，返回结果。                       
  优点：效率高，任务触发时间延迟低。
  缺点：服务器重启后，数据全部消失，怕宕机；集群扩展相当麻烦；因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现 OOM 异常；代码复杂度较高。
  ③时间轮算法
  ④Redis 缓存  思路:
  ⑤使用消息队列 采用 RabbitMQ 的延时队列。RabbitMQ 具有以下两个特性，可以实现延迟队列
                 RabbitMQ 可以针对 Queue 和 Message 设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为 dead letter。
                 lRabbitMQ的 Queue 可以配置 x-dead-letter-exchange 和 x-dead-letter-routing-key（可选）两个参数，用来控制队列内出现了 deadletter，则按照这两个参数重新路由。
                 优点：高效，可以利用 RabbitMQ 的分布式特性轻易的进行横向扩展,消息支持持久化增加了可靠性。
                 缺点：本身的易用度要依赖于 RabbitMQ 的运维，因为要引用 RabbitMQ，所以复杂度和成本变高。
                   
Q：3.讲下Mysql的主从复制 以及为什么要做主从复制
A:主从复制，是指建立一个和主数据库完全一样的数据库环境（称为从数据库），并将主库的操作行为进行复制的过程：将主数据库的DDL和DML的操作日志同步到从数据库上，
  然后在从数据库上对这些日志进行重新执行，来保证从数据库和主数据库的数据的一致性。
  在复杂的业务操作中，经常会有操作导致锁行甚至锁表的情况，如果读写不解耦，会很影响运行中的业务，使用主从复制，让主库负责写，从库负责读。
  即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运行。
  2、保证数据的热备份，主库宕机后能够及时替换主库，保障业务可用性。
  3、架构的演进：业务量扩大，I/O访问频率增高，单机无法满足，主从复制可以做多库方案，降低磁盘I/O访问的频率，提高单机的I/O性能。
  
Q：4.Mysql的主从延迟怎么解决
A:延迟的本质原因是：系统TPS并发较高时，主库产生的DML（也包含一部分DDL）数量超过Slave一个Sql线程所能承受的范围，效率就降低了。
  1.优化系统配置（系统级、链接层、存储引擎层），让数据库处在最优状态：最大连接数、允许错误数、允许超时时间、pool_size、log_size等，保证内存、CPU、存储空间的扩容（硬件部分）。
    如果MySQL部署在linux系统上，可以适当调整操作系统的参数来优化MySQL性能，下面是对Linux内核参数进行适当调整
      1 # TIME_WAIT超时时间，默认是60s 2 net.ipv4.tcp_fin_timeout = 30  3 # 增加tcp支持的队列数，加大队列长度可容纳更多的等待连接 4 net.ipv4.tcp_max_syn_backlog = 65535 5 # 减少断开连接时 ，资源回收 6 net.ipv4.tcp_max_tw_buckets = 8000 7 net.ipv4.tcp_tw_reuse = 1 8 net.ipv4.tcp_tw_recycle = 1 9 net.ipv4.tcp_fin_timeout = 1010 # 打开文件的限制11 *soft nofile 6553512 *hard nofile 65535
    MySQL5.5+版本之后，默认存储引擎为InnoDB，我们这边列出部分可能影响数据库性能的参数。
      1 max_connections = 1512 # 同时处理最大连接数，建议设置最大连接数是上限连接数的80%左右,一般默认值为151，可以做适当调整。3 sort_buffer_size = 2M4 # 查询排序时缓冲区大小，只对order by和group by起作用，建议增大为16M5 open_files_limit = 1024 6 # 打开文件数限制，如果show global status like 'open_files'查看的值等于或者大于open_files_limit值时，程序会无法连接数据库或卡死
    InnoDB参数默认值：
      1 innodb_buffer_pool_size = 128M 2 # 索引和数据缓冲区大小，建议设置物理内存的70%左右（这个前提是这个服务器只用做Mysql数据库服务器） 3 innodb_buffer_pool_instances = 1     4 # 缓冲池实例个数，推荐设置4个或8个 5 innodb_flush_log_at_trx_commit = 1   6 # 关键参数，0代表大约每秒写入到日志并同步到磁盘，数据库故障会丢失1秒左右事务数据。1为每执行一条SQL后写入到日志并同步到磁盘，I/O开销大，执行完SQL要等待日志读写，效率低。2代表只把日志写入到系统缓存区，再每秒同步到磁盘，效率很高，如果服务器故障，才会丢失事务数据。对数据安全性要求不是很高的推荐设置2，性能高，修改后效果明显。 7 sync_binlog=1 8  9 innodb_file_per_table = ON  10 # 是否共享表空间，5.7+版本默认ON，共享表空间idbdata文件不断增大，影响一定的I/O性能。建议开启独立表空间模式，每个表的索引和数据都存在自己独立的表空间中，可以实现单表在不同数据库中移动。11 innodb_log_buffer_size = 8M  12 # 日志缓冲区大小，由于日志最长每秒钟刷新一次，所以一般不用超过16M
  2.数据库层做合理分治
    数据库分区是永恒的话题，主从延迟一定程度上是单台数据库主服务操作过于频繁，使得单线程的SQL thread 疲于应付。可以适当的从功能上对数据库进行拆分，分担压力。
  3.适当引入缓存
    可以引入redis或者其他nosql数据库来存储我们经常会产生主从延迟的业务数据。当我在写入数据库的同时，我们再写入一份到redis中。 
    读取数据的时候，我们可以先去查看redis中是否有这个数据，如果有我们就可以直接从redis中读取这个数据。当数据真正同步到数据库中的时候，再从redis中把数据删除。
        1、虽然一定程度上缓解延迟的问题，但如果遇到高并发的情况，对Redis的频繁删除也不合理，所以需要结合场景综合考虑，比如定期删除缓存。
        2、高并发情况下可能存在slave还没同步，又有新的值写进来了，这时候Master --> Slave 还在排队中，但是Cache已经被更新了。所以如果对Redis进行删除，可能会误删除最新的缓存值，导致读取到的数据是旧的。        
           对一个值分别更新 1，2，3，主从同步按照顺序进行，刚同步完1，Cache就更新到3了，这时候如果把Cache删除了，读请求就会走到从库去读，读到了1，数据就会出现短暂不一致了。
           所以这个地方也需要注意，可以同时将唯一键（比如主键）也做保存，删除之前做一个判断，避免误删。或者干脆不实时删除缓存，低峰值期再来处理。
  4.适当的限流、降级    达到这个上限之后，就要采取缓存，限流，降级的这三大杀招来应对我们的流量。这也是应对主从延迟的根本处理办法。      
    
Q：5.Mysql主从复制的原理是什么
A: 当在从库上启动复制时，首先创建I/O线程连接主库，主库随后创建Binlog Dump线程读取数据库事件并发送给I/O线程，
   I/O线程获取到事件数据后更新到从库的中继日志Relay Log中去，之后从库上的SQL线程读取中继日志Relay Log中更新的数据库事件并应用，
   1、MySQL主库在事务提交时把数据变更（insert、delet、update）作为事件日志记录在二进制日志表（binlog）里面。
   2、主库上有一个工作线程 binlog dump thread，把binlog的内容发送到从库的中继日志relay log中。
   3、从库根据中继日志relay log重做数据变更操作，通过逻辑复制来达到主库和从库的数据一致性。
   4、MySQL通过三个线程来完成主从库间的数据复制，其中binlog dump线程跑在主库上，I/O线程和SQL线程跑在从库上。拥有多个从库的主库会为每一个连接到主库的从库创建一个binlog dump线程。
Q：圆环开关灯算法题