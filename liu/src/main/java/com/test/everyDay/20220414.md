Q:1.静态变量和实例变量的区别是什么
A:静态变量
  也称为类变量，是被static修饰符修饰的变量。可以直接用类名调用，也可以用对象调用，而且所有对象的同一个类变量都是共享同一个内存空间的。
  实例变量
  也叫对象变量，没有static修饰，只能通过对象调用，而且所有对象的同一个实例变量是共享不同内存空间的。
  区别在于：静态变量是所有对象共有的，某一个对象将它的值改变了，其他对象 再去获取它，得到的是改变后的值。
  实例变量则是每一个对象私有的，某一个对象将它的值改变了，不影响其他对象的取值结果，得到的仍是实例变量一开始被赋予的值。
  
Q:2.双亲委派的作用是什么
A:双亲委派机制指的是，当某个特定的类加载器在收到类加载的请求时，会遵循下面的规则顺序：
  1.首先判断被加载的类是否已经加载过，如果是则结束，否则会将加载任务委托给自己的父亲；
  2.父类加载器在收到类加载的请求时，也会先判断被加载的类是否已经加载过，如果是则结束，否则同样将加载任务委托给自己的父亲
  3.不断的循环进行步骤2，直到将加载任务委托给Bootstrap ClassLoader为止。此时，Bootstrap ClassLoader会先判断被加载的类是否已经加载过，如果是则结束；
  请注意，到这里为止，都只是在转移加载任务的请求，下面将会进行类加载 
  4.Bootstrap ClassLoader会判断能否完成加载任务，如果能则直接加载，否则会将加载任务交给儿子类加载器；
  5.儿子类加载器也会判断能否完成加载任务，如果能则直接加载，否则会再一次将加载任务交给儿子类加载器；
  不断的循环进行步骤5，直到最后一个类加载器，如果这个类加载器仍然不能够加载这个类，就会抛出一个异常：ClassNotFoundException。

(1)首先，保证了java核心库的安全性。如果你也写了一个java.lang.String类，那么JVM只会按照上面的顺序加载jdk自带的String类，而不是你写的String类。
(2)其次，还能保证同一个类不会被加载多次。

Q:3.为什么重写equals时也必须重写HashCode
A:hashCode主要用于提升查询效率，来确定在散列结构中对象的存储地址；
  重写equals()必须重写hashCode()，二者参与计算的自身属性字段应该相同；
  hash类型的存储结构，添加元素重复性校验的标准就是先取hashCode值，后判断equals()；
  equals()相等的两个对象，hashcode()一定相等；
  反过来：hashcode()不等，一定能推出equals()也不等；
  hashcode()相等，equals()可能相等，也可能不等。
 
Q:4.Java垃圾回收算法有哪些
  复制算法  复制算法就是从一个地方复制到另外一个地方，针对垃圾回收来说，就是把活着的对象复制到另外一块内存区域，
           然后之前的内存区域中的对象便可以被回收。在同等大小内存前提下，复制算法的内存使用率比较低，因为它会把内存分为两个部分
  标记-清除算法 首先是一个标记的过程，也就是标记出哪些对象是垃圾，然后进行清除操作。该算法不需要像复制算法似的，把内存分为两部分，
               它可以利用整块的内存，在内存利用率上是没有问题的，但是容易产生内存碎片，随着内存的回收，可能在内存中就不存在整块的大内存，
               在分配需要连续空间的大对象（数组）时就会发生OOM.
  标记-整理/压缩算法 标记-整理/压缩，是在标记清除的基础上加了一个内存整理的过程，是为了消除内存碎片的
  分代算法  分代算法，其实不能算是一个垃圾回收的算法，可以理解为一种垃圾回收的方案，即把内存分为不同的块也即代，每一块使用不同的垃圾回收算法。
           现代主流的垃圾回收器都是使用分代的思想.把堆区分为新生代和老年代，新生代又分为Eden S0 S1；新生代使用复制算法，老年代使用标记-清除/标记-整理算法
           
Q:5.Spring静态代理的优缺点是什么
A:静态代理的优点：
  可以使真实角色的操作更加纯粹，不用去关注一些公共的业务
  公共也就交给代理角色，实现了业务的分工
  业务发生扩展的时候，方便集中管理
  静态代理的缺点：
  一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率变低。
  
数据结构:二叉树 平衡二叉树  B树 B+树 