Q:1.为什么redis使用单线程性能优于多线程
A:首先说说Redis是单线程的,其实我们说的是Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。
  计算机程序在执行的过程中,主要是进行计算操作和读写操作。其中读写操作主要设计的是IO操作，包括网络IO和磁盘IO。计算操作主要与CPU有关。
  而多线程的目的，就是通过并发的方式去提升IO和CPU的利用率。
  而redis的操作基本都是基于内存的，所有不用去考虑CPU的性能瓶颈。对于网络IO，redis使用了多路复用IO技术，多线程编程都有一个致命问题：共享资源的并发控制问题，
  而且多线程互相切换也会带来一定的性能开销。
  总结： 1、redis操作基于内存，绝大多数操作的性能瓶颈在内存，带宽大小，不在CPU。
        2、单线程模型开发，调试，维护成本低。
        3、单线程模型避免了线程间切换带来的性能开销。
        4、在单线程中使用多路复用 I/O技术也能提升Redis的I/O利用率

Q:2.什么是redis的缓存预热
A:缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。
  如果不进行预热，那么Redis初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。
  缓存预热解决方案：
  数据量不大的情况下，工程启动的时候进行加载缓存动作
  数据量大的情况下，设置一个定时任务脚本，进行缓存的刷新
  数据量非常大的情况下，优先保证热点数据进行提前加载到缓存
  
Q:3.讲讲你知道IO模型
A:操作系统内部也划分出了内核态和用户态。
  内核态拥有完全的底层资源控制权限，可以执行任何的CPU指令，访问任何内存地址，其占有的处理机是不允许被抢占的.
  用户程序是运行在操作系统之上，这些程序运行时称之为用户态，用户态下不能直接访问底层硬件和内存地址，只能通过委托系统调用的方式来访问底层硬件和内存。
  https://zhuanlan.zhihu.com/p/115912936
  总结：
  阻塞IO:应用进程一直等待数据发出/获取。
  非阻塞IO:应用进程不等待数据发出/获取，而是不断的去发出请求直至达到目的。
  IO复用模型:进程通过将一个或多个fd传递给select，阻塞在select操作上，select帮我们侦测多个fd是否准备就绪，
            当有fd准备就绪时，select返回数据可读状态，应用程序再调用recvfrom读取数据。
  信号驱动IO模型:信号驱动IO不是用循环请求询问的方式去监控数据就绪状态，而是在调用sigaction(发起请求)时候建立一个SIGIO的信号联系，
                当内核数据准备好之后再通过SIGIO信号通知线程数据准备好后的可读状态，当线程收到可读状态的信号后，此时再向内核发起recvfrom读取数据的请求，
                因为信号驱动IO的模型下应用线程在发出信号监控后即可返回，不会阻塞，所以这样的方式下，一个应用线程也可以同时监控多个fd。
  异步IO:应用只需要向内核发送一个read 请求,告诉内核它要读取数据后即刻返回；内核收到请求后会建立一个信号联系，当数据准备就绪，内核会主动把数据从内核复制到用户空间，
         等所有操作都完成之后，内核会发起一个通知告诉应用.
         
Q:4.解决redis缓存一致性问题的方案有哪些 如何采用  redisson读写锁+双检机制   阿里canal
A:常见方案
  1.先更新数据库，再更新缓存 不好
  缺点：
      并发更新问题，比如线程A更新了数据库，线程B更新了数据库，线程B更新了缓存，线程A更新了缓存，这样最终存入的就是脏数据。
  2.先删除缓存，再更新数据库 
  缺点：
      存在脏数据的可能，比如线程A删除缓存，线程B查询缓存不存在数据，从数据库获取，获取成功后，数据存入缓存，现在A更新数据。这样缓存中的数据就是脏数据了。
  修改方案： 先删除缓存，再更新数据库 再删除缓存
  缺点：
      1、多次操作redis删除key 2、延时删除，导致接口性能不高，影响接口吞吐量 3、第二次可能删除失败，还是存在问题
  修改方案： 解决方案，异步删除时可以使用MQ消息队列(比如RocketMq的延时消息)，确保删除成功，删除失败则重试，这种方案对业务代码影响大，
            造成大量的侵入，并且MQ也可能存在消息堆积，删除延迟过长的问题。
  3.先更新数据库，再删除缓存
  虽然也会出现脏数据，但是概率极低，除非是查询比写入慢，要解决也可以采用异步延时删除，而且redis也有过期时间，能够保证最终一致性。
  
  4.依赖binlog  业务更新数据库，更新MySql binlog日志。  获取mySql日志，转换为数据发送至MQ。 业务方监听MQ消息，根据标识更新缓存。
  
  5.分布式锁采用读写锁模式 只有读请求可以并发，单对于写请求独占，这个可以有，系统吞吐量倒也大大提升，毕竟读请求远多于写请求
  
  6.使用redission
Q:5.说一些mysql的存储引擎 都有什么特点
A：1、MyISAM 又可以分为
                 静态MyISAM：如果数据表中的各数据列的长度都是预先固定好的，服务器将自动选择这种表类型。
                             因为数据表中每一条记录所占用的空间都是一样的，所以这种表存取和更新的效率非常高。当数据受损时，恢复工作也比较容易做
                 动态MyISAM：如果数据表中出现varchar、xxxtext或xxxBLOB字段时，服务器将自动选择这种表类型。
                             相对于静态MyISAM，这种表存储空间比较小，但由于每条记录的长度不一，所以多次修改数据后，
                             数据表中的数据就可能离散的存储在内存中，进而导致执行效率下降。同时，内存中也可能会出现很多碎片。
                             因此，这种类型的表要经常用optimize table 命令或优化工具来进行碎片整理。
                 压缩MyISAM：以上说到的两种类型的表都可以用myisamchk工具压缩。这种类型的表进一步减小了占用的存储，但是这种表压缩之后不能再被修改。
                             另外，因为是压缩数据，所以这种表在读取的时候要先时行解压缩。
    但是，不管是何种MyISAM表，目前它都不支持事务，行级锁和外键约束的功能。                          
   2、InnoDB：InnoDB表类型可以看作是对MyISAM的进一步更新产品，它提供了事务、行级锁机制和外键约束的功能。
   3、memory(heap)：这种类型的数据表只存在于内存中。它使用散列索引，所以数据的存取速度非常快。因为是存在于内存中，所以这种类型常应用于临时表中。
   4、MyISAM Merge引擎：这种类型是MyISAM类型的一种变种。合并表是将几个相同的MyISAM表合并为一个虚表。常应用于日志和数据仓库。
   5. archive：这种类型只支持select 和 insert语句，而且不支持索引。常应用于日志记录和聚合分析方面。
 